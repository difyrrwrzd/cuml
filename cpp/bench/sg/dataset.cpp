/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "argparse.hpp"
#include <cstdio>
#include <cuML.hpp>
#include <string>
#include "utils.h"
#include <vector>

namespace ML {
namespace Bench {

void Dataset::allocate(int nr, int nc, const cumlHandle& handle) {
  auto allocator = handle.getDeviceAllocator();
  auto stream = handle.getStream();
  X = (float*)allocator->allocate(nr * nc, stream);
  y = (int*)allocator->allocate(nr, stream);
}

void Dataset::deallocate(const cumlHandle& handle) {
  auto allocator = handle.getDeviceAllocator();
  auto stream = handle.getStream();
  allocator->deallocate(X, nr * nc, stream);
  allocator->deallocate(y, nr, stream);
}

void dumpDataset(const cumlHandle& handle, const Dataset& dataset,
                 const std::string& file) {
  printf("Dumping generated dataset to '%s'\n", file.c_str());
  FILE* fp = std::fopen(file.c_str(), "w");
  ASSERT(fp != nullptr, "Failed to open file '%s' for writing", file.c_str());
  auto stream = handle.getStream();
  CUDA_CHECK(cudaStreamSynchronize(stream));
  std::vector<float> X(dataset.nrows * dataset.ncols);
  std::vector<int> y(dataset.nrows);
  MLCommon::copy(&(X[0]), dataset.X, dataset.nrows * dataset.ncols, stream);
  MLCommon::copy(&(y[0]), dataset.y, dataset.nrows, stream);
  CUDA_CHECK(cudaStreamSynchronize(stream));
  fprintf("%d %d\n", dataset.nrows, dataset.ncols);
  for (int i = 0, k = 0; i< dataset.nrows; ++i) {
    for (int j = 0; j < dataset.ncols; ++j, ++k)
      fprintf(fp, "%f ", X[k]);
    fprintf(fp, "%d\n", y[i]);
  }
  fclose(fp);
}

bool blobs(Dataset& ret, const cumlHandle& handle, char** argv, int argc) {
  bool help = get_argval(argv, argv + argc, "-h");
  if (help) {
    printf(
      "USAGE:\n"
      "bench blobs [options]\n"
      "  Generate a random dataset similar to sklearn's make_blobs.\n"
      "OPTIONS:\n"
      "  -center-box-max <max>   max bounding box for the centers of the\n"
      "                          clusters [10.f].\n"
      "  -center-box-min <min>   min bounding box for the centers of the\n"
      "                          clusters [-10.f].\n"
      "  -cluster-std <std>      cluster std-deviation [1.f].\n"
      "  -dump <file>            dump the generated dataset.\n"
      "  -h                      print this help and exit.\n"
      "  -nclusters <nclusters>  number of clusters to generate [2].\n"
      "  -ncols <ncols>          number of cols in the dataset [81].\n"
      "  -nrows <nrows>          number of rows in the dataset [10001].\n"
      "  -seed <seed>            random seed for reproducibility [1234].\n"
      "  -shuffle                whether to shuffle the dataset.\n");
    return false;
  }
  printf("Generating blobs...\n");
  float centerBoxMax = get_argval(argv, argv + argc, "-center-box-max", 10.f);
  float centerBoxMin = get_argval(argv, argv + argc, "-center-box-min", -10.f);
  float clusterStd = get_argval(argv, argv + argc, "-cluster-std", 1.f);
  std::string dump = get_argval(argv, argv + argc, "-dump", "");
  int nclusters = get_argval(argv, argv + argc, "-nclusters", 2);
  ret.ncols = get_argval(argv, argv + argc, "-ncols", 81);
  ret.nrows = get_argval(argv, argv + argc, "-nrows", 10001);
  ret.allocate(ret.ncols, ret.nrows, handle);
  uint64_t seed = get_argval(argv, argv + argc, "-seed", 1234ULL);
  bool shuffle = get_argval(argv, argv + argc, "-shuffle");
  make_blobs(handle, ret.X, ret.y, nrows, ncols, nclusters,
             nullptr, nullptr, clusterStd, shuffle, centerBoxMin, centerBoxMax,
             seed);
  if (dump != "")
    dumpDataset(handle, dataset, dump);
  return true;
}

bool load(Dataset& ret, const cumlHandle& handle, char** argv, int argc) {
  bool help = get_argval(argv, argv + argc, "-h");
  if (help) {
    printf(
      "USAGE:\n"
      "bench load [options]\n"
      "  Load the dataset from the input text file.\n"
      "OPTIONS:\n"
      "  -file <file>   file containing the dataset. Mandatory. File format\n"
      "                 is the same as generated by the '-dump' option.\n"
      "  -h             print this help and exit.\n");
    return false;
  }
  std::string file = get_argval(argv, argv + argc, "-file", "");
  ASSERT(!file.empty(), "'-file' is a mandatory option");
  printf("Loading dataset from file '%s'...\n", file.c_str());
  FILE* fp = fopen(file.c_str(), "r");
  fscanf(fp, "%d%d", &(ret.nrows), &(ret.ncols));
  std::vector<float> X(ret.nrows * ret.ncols);
  std::vector<int> y(ret.nrows);
  for (int i = 0, k = 0; i < ret.nrows; ++i) {
    for (int j = 0; j < ret.ncols; ++j, ++k)
      fscanf(fp, "%f ", &(X[k]));
    fscanf(fp, "%d\n", &(y[i]));
  }
  fclose(fp);
  ret.allocate(ret.nrows, ret.ncols, handle);
  auto stream = handle.getStream();
  MLCommon::copy(ret.X, &(X[0]), ret.nrows * ret.ncols, stream);
  MLCommon::copy(ret.y, &(y[0]), ret.nrows, stream);
  CUDA_CHECK(cudaStreamSynchronize(stream));
  return true;
}

} // end namespace Bench
} // end namespace ML
